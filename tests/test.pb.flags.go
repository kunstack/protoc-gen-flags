// Copyright 2021 Linka Cloud  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-flags. DO NOT EDIT.

package tests

import (
	"github.com/kunstack/protoc-gen-flags/flags"
	"github.com/kunstack/protoc-gen-flags/types"
	"github.com/kunstack/protoc-gen-flags/utils"
	"github.com/spf13/pflag"
	"google.golang.org/protobuf/types/known/durationpb"
	"google.golang.org/protobuf/types/known/timestamppb"
	"google.golang.org/protobuf/types/known/wrapperspb"
)

var (
	_ = pflag.NewFlagSet
	_ = utils.BuildFlagName
	_ = types.Bool
	_ = flags.Flagger(nil)
	_ = wrapperspb.String
	_ = (*durationpb.Duration)(nil)
	_ = (*timestamppb.Timestamp)(nil)
)

func (x *TestForMessage) AddFlags(fs *pflag.FlagSet, prefix ...string) {
	fs.Float32VarP(&x.Hello, utils.BuildFlagName(prefix, "hello"), "h", x.Hello, "Hello world '\"' flag")

	fs.MarkHidden("hello")

	fs.MarkDeprecated("hello", "This flag is deprecated, use --greeting instead")

	fs.StringVarP(&x.World, utils.BuildFlagName(prefix, "world"), "", x.World, "World flags (can be specified multiple times)")

	fs.MarkDeprecated("world", "This flag is deprecated, use --target instead")

	fs.StringVarP(&x.Greeting, utils.BuildFlagName(prefix, "greeting"), "g", x.Greeting, "Greeting message to display")

	fs.Int32VarP(&x.Count, utils.BuildFlagName(prefix, "count"), "c", x.Count, "Number of times to repeat the message")

	fs.BoolVarP(&x.Verbose, utils.BuildFlagName(prefix, "verbose"), "v", x.Verbose, "Enable verbose output")

	fs.Int64VarP(&x.Verbose2, utils.BuildFlagName(prefix, "verbose2"), "V", x.Verbose2, "Enable verbose output with sfixed64")

	fs.Int64VarP(&x.UserId, utils.BuildFlagName(prefix, "user-id"), "u", x.UserId, "User ID")

	fs.Uint32VarP(&x.Port, utils.BuildFlagName(prefix, "port"), "p", x.Port, "Port number")

	fs.Uint64VarP(&x.Size, utils.BuildFlagName(prefix, "size"), "s", x.Size, "Size in bytes")

	fs.Int32VarP(&x.Temperature, utils.BuildFlagName(prefix, "temperature"), "t", x.Temperature, "Temperature value")

	fs.Int64VarP(&x.Timestamp, utils.BuildFlagName(prefix, "timestamp"), "T", x.Timestamp, "Timestamp value")

	fs.Uint32VarP(&x.Timeout, utils.BuildFlagName(prefix, "timeout"), "", x.Timeout, "Timeout in milliseconds")

	fs.Uint64VarP(&x.Bandwidth, utils.BuildFlagName(prefix, "bandwidth"), "", x.Bandwidth, "Bandwidth in bits per second")

	fs.Int32VarP(&x.Offset, utils.BuildFlagName(prefix, "offset"), "", x.Offset, "Offset value")

	fs.Float64VarP(&x.Ratio, utils.BuildFlagName(prefix, "ratio"), "r", x.Ratio, "Ratio value")

	fs.BytesHexVarP(&x.Byte, utils.BuildFlagName(prefix, "byte"), "b", x.Byte, "Byte data in base64 encoding")

	fs.BytesBase64VarP(&x.ConfigData, utils.BuildFlagName(prefix, "config-data"), "cd", x.ConfigData, "Configuration data in base64 format")

	fs.BytesHexVarP(&x.SecretKey, utils.BuildFlagName(prefix, "secret-key"), "sk", x.SecretKey, "Secret key in hex format")

	fs.MarkHidden("secret-key")

	fs.VarP(types.BytesSlice(&x.FileChunks), utils.BuildFlagName(prefix, "file-chunks"), "fc", "File chunks in base64 format")

	fs.VarP(types.BytesHexSlice(&x.HexChunks), utils.BuildFlagName(prefix, "hex-chunks"), "hc", "Data chunks in hex format")

	fs.VarP(types.EnumSlice(&x.TestEnum), utils.BuildFlagName(prefix, "test-enum"), "e", "Test enum field")

	if x.TimeoutDuration == nil {
		x.TimeoutDuration = new(durationpb.Duration)
	}

	fs.VarP(types.Duration(x.TimeoutDuration), utils.BuildFlagName(prefix, "timeout-duration"), "d", "Timeout duration (e.g., 30s, 5m, 1h)")

	if x.SimpleField == nil {
		x.SimpleField = new(SimpleMessage)
	}

	if v, ok := interface{}(x.SimpleField).(flags.Flagger); ok {
		v.AddFlags(fs, "simple-field")
	}

	fs.StringToStringVarP(&x.Labels, utils.BuildFlagName(prefix, "labels"), "l", x.Labels, "Key-value labels (JSON format)")

	fs.VarP(types.JSON(&x.Counters), utils.BuildFlagName(prefix, "counters"), "", "String-to-integer counters (JSON format)")

	fs.StringToStringVarP(&x.StringMap, utils.BuildFlagName(prefix, "string-map"), "sm", x.StringMap, "String-to-string map using native format")

	fs.VarP(types.StringToInt32(&x.Int32Map), utils.BuildFlagName(prefix, "int32-map"), "i32", "String-to-int32 map using native format")

	fs.StringToInt64VarP(&x.Int64Map, utils.BuildFlagName(prefix, "int64-map"), "i64", x.Int64Map, "String-to-int64 map using native format")

	fs.VarP(types.StringToUint32(&x.Uint32Map), utils.BuildFlagName(prefix, "uint32-map"), "u32", "String-to-uint32 map using native format")

	fs.VarP(types.StringToUint64(&x.Uint64Map), utils.BuildFlagName(prefix, "uint64-map"), "u64", "String-to-uint64 map using native format")

	fs.VarP(types.StringToInt32(&x.Sfixed32Map), utils.BuildFlagName(prefix, "sfixed32-map"), "sf32", "String-to-sfixed32 map using native format")

	fs.StringToInt64VarP(&x.Sfixed64Map, utils.BuildFlagName(prefix, "sfixed64-map"), "sf64", x.Sfixed64Map, "String-to-sfixed64 map using native format")

	fs.VarP(types.JSON(&x.JsonMap), utils.BuildFlagName(prefix, "json-map"), "j", "Generic JSON map format")

	fs.StringSliceVarP(&x.RepeatedStrings, utils.BuildFlagName(prefix, "repeated-strings"), "rs", x.RepeatedStrings, "Repeated strings for comparison")

	fs.VarP(types.DurationSlice(&x.Delays), utils.BuildFlagName(prefix, "delays"), "d", "Delay durations (e.g., 1s, 2m, 3h)")

	fs.VarP(types.DurationSlice(&x.Intervals), utils.BuildFlagName(prefix, "intervals"), "i", "Time intervals between events")

	fs.VarP(types.DurationSlice(&x.Timeouts), utils.BuildFlagName(prefix, "timeouts"), "t", "Timeout durations for operations")

}

func (x *TestForMessage) SetDefaults() {
	if x.SimpleField == nil {
		x.SimpleField = new(SimpleMessage)
	}

	if v, ok := interface{}(x.SimpleField).(flags.Defaulter); ok {
		v.SetDefaults()
	}

}

func (x *SimpleMessage) AddFlags(fs *pflag.FlagSet, prefix ...string) {
	fs.StringVarP(&x.Name, utils.BuildFlagName(prefix, "name"), "", x.Name, "Name parameter")

}

func (x *SimpleMessage) SetDefaults() {
}

func (x *WrapperValueMessage) AddFlags(fs *pflag.FlagSet, prefix ...string) {
	fs.VarP(types.BoolSlice(&x.Name), utils.BuildFlagName(prefix, "name"), "", "Name parameter")

	if x.DoubleValue == nil {
		x.DoubleValue = new(wrapperspb.DoubleValue)
	}
	fs.VarP(types.Double(x.DoubleValue), utils.BuildFlagName(prefix, "double-value"), "dv", "Double value wrapper")

	fs.VarP(types.DoubleSlice(&x.DoubleValues), utils.BuildFlagName(prefix, "double-values"), "dvs", "Multiple double values")

	if x.BytesValue == nil {
		x.BytesValue = new(wrapperspb.BytesValue)
	}

	fs.VarP(types.Bytes(x.BytesValue), utils.BuildFlagName(prefix, "bytes-value"), "bv", "Bytes value wrapper (base64 encoded)")

	fs.VarP(types.BytesSlice(&x.BytesValues), utils.BuildFlagName(prefix, "bytes-values"), "bvs", "Multiple bytes values (base64 encoded)")

	fs.VarP(types.BytesHexSlice(&x.BytesHexValues), utils.BuildFlagName(prefix, "bytes-hex-values"), "bhx", "Multiple bytes values (hex encoded)")

}

func (x *WrapperValueMessage) SetDefaults() {
}

func (x *DoubleSliceTestMessage) AddFlags(fs *pflag.FlagSet, prefix ...string) {
	fs.VarP(types.DoubleSlice(&x.Measurements), utils.BuildFlagName(prefix, "measurements"), "m", "Scientific measurements (e.g., 3.14159, 2.71828, 1.41421)")

	fs.VarP(types.DoubleSlice(&x.ScientificValues), utils.BuildFlagName(prefix, "scientific-values"), "sv", "Scientific notation values (e.g., 1.23e-4, 5.67e+8)")

	fs.VarP(types.DoubleSlice(&x.TemperatureReadings), utils.BuildFlagName(prefix, "temperature-readings"), "t", "Temperature readings in Celsius")

	fs.VarP(types.DoubleSlice(&x.Coordinates), utils.BuildFlagName(prefix, "coordinates"), "c", "GPS coordinates (lat, lon pairs)")

}

func (x *DoubleSliceTestMessage) SetDefaults() {
}

func (x *BytesSliceTestMessage) AddFlags(fs *pflag.FlagSet, prefix ...string) {
	fs.VarP(types.BytesSlice(&x.DataChunks), utils.BuildFlagName(prefix, "data-chunks"), "dc", "Data chunks in base64 format")

	fs.VarP(types.BytesSlice(&x.FileContents), utils.BuildFlagName(prefix, "file-contents"), "fc", "File contents in base64 format")

	fs.VarP(types.BytesHexSlice(&x.HexData), utils.BuildFlagName(prefix, "hex-data"), "hd", "Data in hexadecimal format")

	fs.VarP(types.BytesHexSlice(&x.BinaryPayloads), utils.BuildFlagName(prefix, "binary-payloads"), "bp", "Binary payloads in hex format")

}

func (x *BytesSliceTestMessage) SetDefaults() {
}

func (x *FloatSliceTestMessage) AddFlags(fs *pflag.FlagSet, prefix ...string) {
	fs.Float32SliceVarP(&x.Measurements, utils.BuildFlagName(prefix, "measurements"), "m", x.Measurements, "Scientific measurements (e.g., 3.14, 2.71, 1.41)")

	if x.Coordinates2 == nil {
		x.Coordinates2 = new(float32)
	}
	fs.Float32VarP(x.Coordinates2, utils.BuildFlagName(prefix, "coordinates"), "c", *(x.Coordinates2), "GPS coordinates in float format")

	fs.Float32SliceVarP(&x.Temperatures, utils.BuildFlagName(prefix, "temperatures"), "t", x.Temperatures, "Temperature readings in Celsius")

	fs.Float32SliceVarP(&x.Percentages, utils.BuildFlagName(prefix, "percentages"), "p", x.Percentages, "Percentage values (0.0 to 100.0)")

}

func (x *FloatSliceTestMessage) SetDefaults() {
}

func (x *FloatValueTestMessage) AddFlags(fs *pflag.FlagSet, prefix ...string) {
	if x.SingleValue == nil {
		x.SingleValue = new(wrapperspb.FloatValue)
	}
	fs.VarP(types.Float(x.SingleValue), utils.BuildFlagName(prefix, "single-value"), "sv", "Single float value wrapper")

	fs.VarP(types.FloatSlice(&x.FloatValues), utils.BuildFlagName(prefix, "float-values"), "fvs", "Multiple FloatValue wrapper instances")

	if x.Temperature == nil {
		x.Temperature = new(wrapperspb.FloatValue)
	}
	fs.VarP(types.Float(x.Temperature), utils.BuildFlagName(prefix, "temperature"), "temp", "Temperature in Celsius")

	fs.VarP(types.FloatSlice(&x.SensorReadings), utils.BuildFlagName(prefix, "sensor-readings"), "sr", "Multiple sensor readings")

	if x.Probability == nil {
		x.Probability = new(wrapperspb.FloatValue)
	}
	fs.VarP(types.Float(x.Probability), utils.BuildFlagName(prefix, "probability"), "prob", "Probability value (0.0 to 1.0)")

	fs.VarP(types.FloatSlice(&x.Scores), utils.BuildFlagName(prefix, "scores"), "sc", "Multiple score values")

}

func (x *FloatValueTestMessage) SetDefaults() {
}

func (x *DurationSliceTestMessage) AddFlags(fs *pflag.FlagSet, prefix ...string) {
	fs.VarP(types.DurationSlice(&x.Delays), utils.BuildFlagName(prefix, "delays"), "d", "Delay durations (e.g., 1s, 2m, 3h)")

	fs.VarP(types.DurationSlice(&x.Intervals), utils.BuildFlagName(prefix, "intervals"), "i", "Time intervals between events (e.g., 500ms, 10s, 5m)")

	fs.VarP(types.DurationSlice(&x.Timeouts), utils.BuildFlagName(prefix, "timeouts"), "t", "Timeout durations for operations (e.g., 30s, 5m, 1h)")

	fs.VarP(types.DurationSlice(&x.PollingIntervals), utils.BuildFlagName(prefix, "polling-intervals"), "p", "Polling intervals for monitoring (e.g., 100ms, 5s, 1m)")

	if x.Deadline == nil {
		x.Deadline = new(timestamppb.Timestamp)
	}

	fs.VarP(types.Timestamp(x.Deadline, []string{"abc"}), utils.BuildFlagName(prefix, "deadline"), "", "deadline usage")

	if x.OptionalDeadline == nil {
		x.OptionalDeadline = new(timestamppb.Timestamp)
	}

	fs.VarP(types.Timestamp(x.OptionalDeadline, []string{"abc"}), utils.BuildFlagName(prefix, "optionaldeadline"), "", "optional_deadline")

}

func (x *DurationSliceTestMessage) SetDefaults() {
}

func (x *EmptyMessage) AddFlags(fs *pflag.FlagSet, prefix ...string) {
}

func (x *EmptyMessage) SetDefaults() {
}

func (x *WrapperMessage) AddFlags(fs *pflag.FlagSet, prefix ...string) {
	if x.Value == nil {
		x.Value = new(wrapperspb.FloatValue)
	}
	fs.VarP(types.Float(x.Value), utils.BuildFlagName(prefix, "value"), "", "hello")

	fs.StringSliceVarP(&x.Value2, utils.BuildFlagName(prefix, "value2"), "", x.Value2, "This should not appear in help")

}

func (x *WrapperMessage) SetDefaults() {
}

func (x *UnexportedMessageTest) _AddFlags(fs *pflag.FlagSet, prefix ...string) {
	fs.StringVarP(&x.SecretKey, utils.BuildFlagName(prefix, "secret-key"), "", x.SecretKey, "Secret configuration key")

	fs.MarkHidden("secret-key")

	fs.Int32VarP(&x.Timeout, utils.BuildFlagName(prefix, "timeout"), "", x.Timeout, "Connection timeout in seconds")

}

func (x *UnexportedMessageTest) _SetDefaults() {
	if x.Timeout == 0 {
		x.Timeout = 30
	}

}

func (x *DefaultValueTestMessage) AddFlags(fs *pflag.FlagSet, prefix ...string) {
	fs.Float32VarP(&x.Pi, utils.BuildFlagName(prefix, "pi"), "", x.Pi, "Pi constant value")

	fs.Float64VarP(&x.Euler, utils.BuildFlagName(prefix, "euler"), "", x.Euler, "Euler's number")

	fs.Int32VarP(&x.DefaultPort, utils.BuildFlagName(prefix, "default-port"), "", x.DefaultPort, "Default server port")

	fs.Int64VarP(&x.MaxConnections, utils.BuildFlagName(prefix, "max-connections"), "", x.MaxConnections, "Maximum allowed connections")

	fs.Uint32VarP(&x.BufferSize, utils.BuildFlagName(prefix, "buffer-size"), "", x.BufferSize, "Buffer size in bytes")

	fs.Uint64VarP(&x.MemoryLimit, utils.BuildFlagName(prefix, "memory-limit"), "", x.MemoryLimit, "Memory limit in bytes")

	if x.DebugMode == nil {
		x.DebugMode = new(bool)
	}
	fs.BoolVarP(x.DebugMode, utils.BuildFlagName(prefix, "debug-mode"), "", *(x.DebugMode), "Enable debug mode")

	fs.StringVarP(&x.LogLevel, utils.BuildFlagName(prefix, "log-level"), "", x.LogLevel, "Default log level")

	fs.VarP(types.Enum(&x.DefaultMode), utils.BuildFlagName(prefix, "default-mode"), "", "Default operation mode")

	if x.DefaultMode2 == nil {
		x.DefaultMode2 = new(TestEnum1)
	}

	fs.VarP(types.Enum(x.DefaultMode2), utils.BuildFlagName(prefix, "default-mode1"), "", "Default operation mode")

}

func (x *DefaultValueTestMessage) SetDefaults() {
	if x.Pi == 0 {
		x.Pi = 3.14159
	}

	if x.Euler == 0 {
		x.Euler = 2.71828
	}

	if x.DefaultPort == 0 {
		x.DefaultPort = 8080
	}

	if x.MaxConnections == 0 {
		x.MaxConnections = 1000
	}

	if x.BufferSize == 0 {
		x.BufferSize = 4096
	}

	if x.MemoryLimit == 0 {
		x.MemoryLimit = 1073741824
	}

	if x.DebugMode == nil {
		v := bool(true)
		x.DebugMode = &v
	}

}

func (x *StringValueTestMessage) AddFlags(fs *pflag.FlagSet, prefix ...string) {
	if x.SingleValue == nil {
		x.SingleValue = new(wrapperspb.StringValue)
	}
	fs.VarP(types.String(x.SingleValue), utils.BuildFlagName(prefix, "single-value"), "sv", "Single string value wrapper")

	fs.VarP(types.StringSlice(&x.StringValues), utils.BuildFlagName(prefix, "string-values"), "svs", "Multiple StringValue wrapper instances")

	if x.ConfigPath == nil {
		x.ConfigPath = new(wrapperspb.StringValue)
	}
	fs.VarP(types.String(x.ConfigPath), utils.BuildFlagName(prefix, "config-path"), "cfg", "Configuration file path")

	fs.VarP(types.StringSlice(&x.IncludePaths), utils.BuildFlagName(prefix, "include-paths"), "inc", "Include paths for configuration")

	if x.Environment == nil {
		x.Environment = new(wrapperspb.StringValue)
	}
	fs.VarP(types.String(x.Environment), utils.BuildFlagName(prefix, "environment"), "env", "Environment name")

	fs.VarP(types.StringSlice(&x.Tags), utils.BuildFlagName(prefix, "tags"), "t", "Multiple tags for categorization")

}

func (x *StringValueTestMessage) SetDefaults() {
}

func (x *IntegerValueTestMessage) AddFlags(fs *pflag.FlagSet, prefix ...string) {
	if x.Int32Value == nil {
		x.Int32Value = new(wrapperspb.Int32Value)
	}
	fs.VarP(types.Int32(x.Int32Value), utils.BuildFlagName(prefix, "int32-value"), "i32", "Int32 value wrapper")

	if x.Int64Value == nil {
		x.Int64Value = new(wrapperspb.Int64Value)
	}
	fs.VarP(types.Int64(x.Int64Value), utils.BuildFlagName(prefix, "int64-value"), "i64", "Int64 value wrapper")

	if x.Uint32Value == nil {
		x.Uint32Value = new(wrapperspb.UInt32Value)
	}
	fs.VarP(types.UInt32(x.Uint32Value), utils.BuildFlagName(prefix, "uint32-value"), "u32", "UInt32 value wrapper")

	if x.Uint64Value == nil {
		x.Uint64Value = new(wrapperspb.UInt64Value)
	}
	fs.VarP(types.UInt64(x.Uint64Value), utils.BuildFlagName(prefix, "uint64-value"), "u64", "UInt64 value wrapper")

	fs.VarP(types.Int32Slice(&x.Int32Values), utils.BuildFlagName(prefix, "int32-values"), "i32s", "Multiple Int32 value wrapper instances")

	fs.VarP(types.Int64Slice(&x.Int64Values), utils.BuildFlagName(prefix, "int64-values"), "i64s", "Multiple Int64 value wrapper instances")

}

func (x *IntegerValueTestMessage) SetDefaults() {
	if x.Int32Value == nil {
		x.Int32Value = &wrapperspb.Int32Value{Value: 42}
	}

	if x.Int64Value == nil {
		x.Int64Value = &wrapperspb.Int64Value{Value: 9223372036854775807}
	}

	if x.Uint32Value == nil {
		x.Uint32Value = &wrapperspb.UInt32Value{Value: 100}
	}

	if x.Uint64Value == nil {
		x.Uint64Value = &wrapperspb.UInt64Value{Value: 18446744073709551615}
	}

}

func (x *BoolValueTestMessage) AddFlags(fs *pflag.FlagSet, prefix ...string) {
	if x.SingleValue == nil {
		x.SingleValue = new(wrapperspb.BoolValue)
	}
	fs.VarP(types.Bool(x.SingleValue), utils.BuildFlagName(prefix, "single-value"), "sv", "Single boolean value wrapper")

	fs.VarP(types.BoolSlice(&x.BoolValues), utils.BuildFlagName(prefix, "bool-values"), "bvs", "Multiple BoolValue wrapper instances")

	if x.EnableFeature == nil {
		x.EnableFeature = new(wrapperspb.BoolValue)
	}
	fs.VarP(types.Bool(x.EnableFeature), utils.BuildFlagName(prefix, "enable-feature"), "feat", "Enable experimental feature")

	fs.VarP(types.BoolSlice(&x.FeatureFlags), utils.BuildFlagName(prefix, "feature-flags"), "ff", "Multiple feature flags")

	if x.VerboseLogging == nil {
		x.VerboseLogging = new(wrapperspb.BoolValue)
	}
	fs.VarP(types.Bool(x.VerboseLogging), utils.BuildFlagName(prefix, "verbose-logging"), "verbose", "Enable verbose logging")

	fs.VarP(types.BoolSlice(&x.DebugOptions), utils.BuildFlagName(prefix, "debug-options"), "dbg", "Multiple debug option flags")

}

func (x *BoolValueTestMessage) SetDefaults() {
	if x.SingleValue == nil {
		x.SingleValue = &wrapperspb.BoolValue{Value: true}
	}

	if x.EnableFeature == nil {
		x.EnableFeature = &wrapperspb.BoolValue{Value: false}
	}

	if x.VerboseLogging == nil {
		x.VerboseLogging = &wrapperspb.BoolValue{Value: false}
	}

}

func (x *ComprehensiveFlagTestMessage) AddFlags(fs *pflag.FlagSet, prefix ...string) {
	fs.StringVarP(&x.Username, utils.BuildFlagName(prefix, "username"), "u", x.Username, "Username for authentication")

	fs.StringVarP(&x.Password, utils.BuildFlagName(prefix, "password"), "p", x.Password, "Password for authentication")

	fs.MarkHidden("password")

	fs.StringVarP(&x.LegacyToken, utils.BuildFlagName(prefix, "legacy-token"), "lt", x.LegacyToken, "Legacy authentication token")

	fs.MarkDeprecated("legacy-token", "Use --api-key instead")

	fs.Int32VarP(&x.ConnectionCount, utils.BuildFlagName(prefix, "connection-count"), "cc", x.ConnectionCount, "Number of concurrent connections")

	fs.Int32VarP(&x.MaxThreads, utils.BuildFlagName(prefix, "max-threads"), "mt", x.MaxThreads, "Maximum number of threads")

	fs.MarkDeprecated("max-threads", "Use --worker-count instead")

	fs.BoolVarP(&x.ExperimentalMode, utils.BuildFlagName(prefix, "experimental-mode"), "exp", x.ExperimentalMode, "Enable experimental features")

	fs.MarkHidden("experimental-mode")

}

func (x *ComprehensiveFlagTestMessage) SetDefaults() {
	if x.ConnectionCount == 0 {
		x.ConnectionCount = 10
	}

	if x.MaxThreads == 0 {
		x.MaxThreads = 100
	}

	if x.ExperimentalMode == false {
		x.ExperimentalMode = false
	}

}

func (x *NestedMessageTestMessage) AddFlags(fs *pflag.FlagSet, prefix ...string) {
	if x.ServerConfig == nil {
		x.ServerConfig = new(SimpleMessage)
	}

	if v, ok := interface{}(x.ServerConfig).(flags.Flagger); ok {
		v.AddFlags(fs, "server")
	}

	if x.ClientConfig == nil {
		x.ClientConfig = new(SimpleMessage)
	}

	if v, ok := interface{}(x.ClientConfig).(flags.Flagger); ok {
		v.AddFlags(fs, "client_config")
	}

	if x.DatabaseConfig == nil {
		x.DatabaseConfig = new(SimpleMessage)
	}

	if v, ok := interface{}(x.DatabaseConfig).(flags.Flagger); ok {
		v.AddFlags(fs, "db")
	}

	if x.DeepConfig == nil {
		x.DeepConfig = new(NestedLevel2Message)
	}

	if v, ok := interface{}(x.DeepConfig).(flags.Flagger); ok {
		v.AddFlags(fs, "app")
	}

}

func (x *NestedMessageTestMessage) SetDefaults() {
	if x.ServerConfig == nil {
		x.ServerConfig = new(SimpleMessage)
	}

	if v, ok := interface{}(x.ServerConfig).(flags.Defaulter); ok {
		v.SetDefaults()
	}

	if x.ClientConfig == nil {
		x.ClientConfig = new(SimpleMessage)
	}

	if v, ok := interface{}(x.ClientConfig).(flags.Defaulter); ok {
		v.SetDefaults()
	}

	if x.DatabaseConfig == nil {
		x.DatabaseConfig = new(SimpleMessage)
	}

	if v, ok := interface{}(x.DatabaseConfig).(flags.Defaulter); ok {
		v.SetDefaults()
	}

	if x.DeepConfig == nil {
		x.DeepConfig = new(NestedLevel2Message)
	}

	if v, ok := interface{}(x.DeepConfig).(flags.Defaulter); ok {
		v.SetDefaults()
	}

}

func (x *NestedLevel2Message) AddFlags(fs *pflag.FlagSet, prefix ...string) {
	fs.StringVarP(&x.Level2Field, utils.BuildFlagName(prefix, "level2-field"), "", x.Level2Field, "Level 2 nested field")

	if x.NestedSimple == nil {
		x.NestedSimple = new(SimpleMessage)
	}

	if v, ok := interface{}(x.NestedSimple).(flags.Flagger); ok {
		v.AddFlags(fs, "nested")
	}

}

func (x *NestedLevel2Message) SetDefaults() {
	if x.NestedSimple == nil {
		x.NestedSimple = new(SimpleMessage)
	}

	if v, ok := interface{}(x.NestedSimple).(flags.Defaulter); ok {
		v.SetDefaults()
	}

}

func (x *ComprehensiveMapTestMessage) AddFlags(fs *pflag.FlagSet, prefix ...string) {
	fs.VarP(types.JSON(&x.JsonLabels), utils.BuildFlagName(prefix, "json-labels"), "jl", "Labels in JSON format")

	fs.StringToStringVarP(&x.NativeLabels, utils.BuildFlagName(prefix, "native-labels"), "nl", x.NativeLabels, "Labels in native format")

	fs.VarP(types.StringToInt32(&x.DefaultCounters), utils.BuildFlagName(prefix, "default-counters"), "dc", "Default counter values")

	fs.VarP(types.JSON(&x.LegacyConfig), utils.BuildFlagName(prefix, "legacy-config"), "lc", "Legacy configuration map")

	fs.MarkDeprecated("legacy-config", "Use --new-config instead")

	fs.VarP(types.JSON(&x.SecretConfig), utils.BuildFlagName(prefix, "secret-config"), "sc", "Secret configuration map")

	fs.MarkHidden("secret-config")

}

func (x *ComprehensiveMapTestMessage) SetDefaults() {
}

func (x *TimestampSliceTestMessage) AddFlags(fs *pflag.FlagSet, prefix ...string) {
	fs.VarP(types.TimestampSlice(&x.EventTimes, []string{"RFC3339"}), utils.BuildFlagName(prefix, "event-times"), "et", "Event timestamps (e.g., 2023-01-01T00:00:00Z, 2023-12-31T23:59:59Z)")

	fs.VarP(types.TimestampSlice(&x.LogTimestamps, []string{"RFC3339"}), utils.BuildFlagName(prefix, "log-timestamps"), "lt", "Log entry timestamps in RFC3339 format")

	fs.VarP(types.TimestampSlice(&x.ScheduledTasks, []string{"RFC3339"}), utils.BuildFlagName(prefix, "scheduled-tasks"), "st", "Scheduled task execution times")

	fs.VarP(types.TimestampSlice(&x.BackupTimes, []string{"RFC3339"}), utils.BuildFlagName(prefix, "backup-times"), "bt", "Backup schedule timestamps (e.g., 2024-01-01T02:00:00Z)")

	fs.VarP(types.TimestampSlice(&x.CustomFormatTimes, []string{"RFC3339", "ISO8601", "RFC822"}), utils.BuildFlagName(prefix, "custom-format-times"), "cft", "Custom format timestamps")

}

func (x *TimestampSliceTestMessage) SetDefaults() {
}
