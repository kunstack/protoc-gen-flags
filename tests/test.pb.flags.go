// Code generated by protoc-gen-flags. DO NOT EDIT.

package tests

import (
	"github.com/kunstack/protoc-gen-flags/flags"
	"github.com/kunstack/protoc-gen-flags/types"
	"github.com/kunstack/protoc-gen-flags/utils"
	"github.com/spf13/pflag"
	"google.golang.org/protobuf/types/known/durationpb"
	"google.golang.org/protobuf/types/known/timestamppb"
	"google.golang.org/protobuf/types/known/wrapperspb"

	types1 "github.com/kunstack/protoc-gen-flags/tests/types"
	utils1 "github.com/kunstack/protoc-gen-flags/tests/utils"
	utils2 "github.com/kunstack/protoc-gen-flags/tests/utils/utils"
	wrapperspb1 "github.com/kunstack/protoc-gen-flags/tests/wrapperspb"
)

var (
	_ = pflag.NewFlagSet
	_ = utils.MustDecodeBase64
	_ = types.Bool
	_ = flags.Flagger(nil)
	_ = wrapperspb.String
	_ = (*durationpb.Duration)(nil)
	_ = (*timestamppb.Timestamp)(nil)
)

func (x *TestForMessage) AddFlags(fs *pflag.FlagSet, opts ...flags.Option) {
	builder := flags.NewNameBuilder(opts...)
	_ = builder
	if x.CustomWrapper == nil {
		x.CustomWrapper = new(wrapperspb1.CustomWrapper)
	}

	if v, ok := interface{}(x.CustomWrapper).(flags.Flagger); ok {
		v.AddFlags(fs, append(opts, flags.WithPrefix("custom_wrapper"))...)
	}

	if x.SimpleMessage == nil {
		x.SimpleMessage = new(utils1.SimpleMessage)
	}

	if v, ok := interface{}(x.SimpleMessage).(flags.Flagger); ok {
		v.AddFlags(fs, append(opts, flags.WithPrefix("simple-messagex1"))...)
	}

	fs.Float32VarP(&x.Hello, builder.Build("hello"), "h", x.Hello, "Hello world '\"' flag")

	fs.MarkHidden("hello")

	fs.MarkDeprecated("hello", "This flag is deprecated, use --greeting instead")

	fs.StringVarP(&x.World, builder.Build("world"), "", x.World, "World flags (can be specified multiple times)")

	fs.MarkDeprecated("world", "This flag is deprecated, use --target instead")

	fs.StringVarP(&x.Greeting, builder.Build("greeting"), "g", x.Greeting, "Greeting message to display")

	fs.Int32VarP(&x.Count, builder.Build("count"), "c", x.Count, "Number of times to repeat the message")

	fs.BoolVarP(&x.Verbose, builder.Build("verbose"), "v", x.Verbose, "Enable verbose output")

	fs.Int64VarP(&x.Verbose2, builder.Build("verbose2"), "V", x.Verbose2, "Enable verbose output with sfixed64")

	fs.Int64VarP(&x.UserId, builder.Build("user-id"), "u", x.UserId, "User ID")

	fs.Uint32VarP(&x.Port, builder.Build("port"), "p", x.Port, "Port number")

	fs.Uint64VarP(&x.Size, builder.Build("size"), "s", x.Size, "Size in bytes")

	fs.Int32VarP(&x.Temperature, builder.Build("temperature"), "t", x.Temperature, "Temperature value")

	fs.Int64VarP(&x.Timestamp, builder.Build("timestamp"), "T", x.Timestamp, "Timestamp value")

	fs.Uint32VarP(&x.Timeout, builder.Build("timeout"), "", x.Timeout, "Timeout in milliseconds")

	fs.Uint64VarP(&x.Bandwidth, builder.Build("bandwidth"), "", x.Bandwidth, "Bandwidth in bits per second")

	fs.Int32VarP(&x.Offset, builder.Build("offset"), "", x.Offset, "Offset value")

	fs.Float64VarP(&x.Ratio, builder.Build("ratio"), "r", x.Ratio, "Ratio value")

	fs.BytesHexVarP(&x.Byte, builder.Build("byte"), "b", x.Byte, "Byte data in base64 encoding")

	fs.BytesBase64VarP(&x.ConfigData, builder.Build("config-data"), "cd", x.ConfigData, "Configuration data in base64 format")

	fs.BytesHexVarP(&x.SecretKey, builder.Build("secret-key"), "sk", x.SecretKey, "Secret key in hex format")

	fs.MarkHidden("secret-key")

	fs.VarP(types.BytesSlice(&x.FileChunks), builder.Build("file-chunks"), "fc", "File chunks in base64 format")

	fs.VarP(types.BytesHexSlice(&x.HexChunks), builder.Build("hex-chunks"), "hc", "Data chunks in hex format")

	fs.VarP(types.BytesSlice(&x.Base64Defaults), builder.Build("base64-defaults"), "bd", "Default base64 encoded values")

	fs.VarP(types.BytesHexSlice(&x.HexDefaults), builder.Build("hex-defaults"), "hd", "Default hex encoded values")

	fs.VarP(types.EnumSlice(&x.TestEnum), builder.Build("test-enum"), "e", "Test enum field")

	if x.TimeoutDuration == nil {
		x.TimeoutDuration = new(durationpb.Duration)
	}

	fs.VarP(types.Duration(x.TimeoutDuration), builder.Build("timeout-duration"), "d", "Timeout duration (e.g., 30s, 5m, 1h)")

	if x.SimpleField == nil {
		x.SimpleField = new(SimpleMessage)
	}

	if v, ok := interface{}(x.SimpleField).(flags.Flagger); ok {
		v.AddFlags(fs, append(opts, flags.WithPrefix("simple-field"))...)
	}

	fs.StringToStringVarP(&x.Labels, builder.Build("labels"), "l", x.Labels, "Key-value labels (JSON format)")

	fs.VarP(types.JSON(&x.Counters), builder.Build("counters"), "", "String-to-integer counters (JSON format)")

	fs.StringToStringVarP(&x.StringMap, builder.Build("string-map"), "sm", x.StringMap, "String-to-string map using native format")

	fs.VarP(types.StringToInt32(&x.Int32Map), builder.Build("int32-map"), "i32", "String-to-int32 map using native format")

	fs.StringToInt64VarP(&x.Int64Map, builder.Build("int64-map"), "i64", x.Int64Map, "String-to-int64 map using native format")

	fs.VarP(types.StringToUint32(&x.Uint32Map), builder.Build("uint32-map"), "u32", "String-to-uint32 map using native format")

	fs.VarP(types.StringToUint64(&x.Uint64Map), builder.Build("uint64-map"), "u64", "String-to-uint64 map using native format")

	fs.VarP(types.StringToInt32(&x.Sfixed32Map), builder.Build("sfixed32-map"), "sf32", "String-to-sfixed32 map using native format")

	fs.StringToInt64VarP(&x.Sfixed64Map, builder.Build("sfixed64-map"), "sf64", x.Sfixed64Map, "String-to-sfixed64 map using native format")

	fs.VarP(types.JSON(&x.JsonMap), builder.Build("json-map"), "j", "Generic JSON map format")

	fs.StringSliceVarP(&x.RepeatedStrings, builder.Build("repeated-strings"), "rs", x.RepeatedStrings, "Repeated strings for comparison")

	fs.VarP(types.DurationSlice(&x.Delays), builder.Build("delays"), "d", "Delay durations (e.g., 1s, 2m, 3h)")

	fs.VarP(types.DurationSlice(&x.Intervals), builder.Build("intervals"), "i", "Time intervals between events")

	fs.VarP(types.DurationSlice(&x.Timeouts), builder.Build("timeouts"), "t", "Timeout durations for operations")

	if x.NestedTest == nil {
		x.NestedTest = new(utils2.NestedMessage)
	}

	if v, ok := interface{}(x.NestedTest).(flags.Flagger); ok {
		v.AddFlags(fs, append(opts, flags.WithPrefix("nested-test"))...)
	}

	if x.CustomType == nil {
		x.CustomType = new(types1.CustomType)
	}

	if v, ok := interface{}(x.CustomType).(flags.Flagger); ok {
		v.AddFlags(fs, append(opts, flags.WithPrefix("custom-type"))...)
	}

}

func (x *TestForMessage) SetDefaults() {
	if x.CustomWrapper == nil {
		x.CustomWrapper = new(wrapperspb1.CustomWrapper)
	}

	if v, ok := interface{}(x.CustomWrapper).(flags.Defaulter); ok {
		v.SetDefaults()
	}

	if x.SimpleMessage == nil {
		x.SimpleMessage = new(utils1.SimpleMessage)
	}

	if v, ok := interface{}(x.SimpleMessage).(flags.Defaulter); ok {
		v.SetDefaults()
	}

	if len(x.Byte) == 0 {
		x.Byte = utils.MustDecodeHex("0000546573742048656c6c6f2054657874")
	}
	if len(x.ConfigData) == 0 {
		x.ConfigData = utils.MustDecodeBase64("aGVsbG8gd29ybGQ=")
	}
	if len(x.Base64Defaults) == 0 {
		x.Base64Defaults = []*wrapperspb.BytesValue{{Value: utils.MustDecodeBase64("aGVsbG8gd29ybGQ=")}, {Value: utils.MustDecodeBase64("dGVzdCBkYXRh")}, {Value: utils.MustDecodeBase64("c2FtcGxlIGNvbnRlbnQ=")}}
	}
	if len(x.HexDefaults) == 0 {
		x.HexDefaults = [][]byte{utils.MustDecodeHex("48656c6c6f20576f726c64"), utils.MustDecodeHex("546573742044617461"), utils.MustDecodeHex("53616d706c6520436f6e74656e74")}
	}
	if len(x.TestEnum) == 0 {
		x.TestEnum = []TestEnum1{1, 3}
	}

	if x.TimeoutDuration == nil {
		x.TimeoutDuration = &durationpb.Duration{Seconds: 30, Nanos: 0}
	}
	if x.SimpleField == nil {
		x.SimpleField = new(SimpleMessage)
	}

	if v, ok := interface{}(x.SimpleField).(flags.Defaulter); ok {
		v.SetDefaults()
	}

	if x.NestedTest == nil {
		x.NestedTest = new(utils2.NestedMessage)
	}

	if v, ok := interface{}(x.NestedTest).(flags.Defaulter); ok {
		v.SetDefaults()
	}

	if x.CustomType == nil {
		x.CustomType = new(types1.CustomType)
	}

	if v, ok := interface{}(x.CustomType).(flags.Defaulter); ok {
		v.SetDefaults()
	}

}

func (x *SimpleMessage) AddFlags(fs *pflag.FlagSet, opts ...flags.Option) {
	builder := flags.NewNameBuilder(opts...)
	_ = builder
	fs.StringVarP(&x.Name, builder.Build("name"), "", x.Name, "Name parameter")

	if x.CreatedAt == nil {
		x.CreatedAt = new(timestamppb.Timestamp)
	}

	fs.VarP(types.Timestamp(x.CreatedAt, []string{"RFC3339", "ISO8601"}), builder.Build("created-at"), "", "Creation timestamp")

}

func (x *SimpleMessage) SetDefaults() {
	if x.CreatedAt == nil {
		x.CreatedAt = &timestamppb.Timestamp{Seconds: 1672531200, Nanos: 0}
	}

}

func (x *WrapperValueMessage) AddFlags(fs *pflag.FlagSet, opts ...flags.Option) {
	builder := flags.NewNameBuilder(opts...)
	_ = builder
	fs.VarP(types.BoolSlice(&x.Name), builder.Build("name"), "", "Name parameter")

	if x.DoubleValue == nil {
		x.DoubleValue = new(wrapperspb.DoubleValue)
	}
	fs.VarP(types.Double(x.DoubleValue), builder.Build("double-value"), "dv", "Double value wrapper")

	fs.VarP(types.DoubleSlice(&x.DoubleValues), builder.Build("double-values"), "dvs", "Multiple double values")

	if x.BytesValue == nil {
		x.BytesValue = new(wrapperspb.BytesValue)
	}

	fs.VarP(types.Bytes(x.BytesValue), builder.Build("bytes-value"), "bv", "Bytes value wrapper (base64 encoded)")

	if x.BytesValues == nil {
		x.BytesValues = new(wrapperspb.BytesValue)
	}

	fs.VarP(types.Bytes(x.BytesValues), builder.Build("bytes-values"), "bvs", "Multiple bytes values (base64 encoded)")

	fs.VarP(types.BytesHexSlice(&x.BytesHexValues), builder.Build("bytes-hex-values666"), "bhx", "Multiple bytes values (hex encoded)")

	if x.BytesHexValuesx == nil {
		x.BytesHexValuesx = new(wrapperspb.BytesValue)
	}

	fs.VarP(types.Bytes(x.BytesHexValuesx), builder.Build("bytes-hex-values"), "bhx", "Multiple bytes values (hex encoded)")

}

func (x *WrapperValueMessage) SetDefaults() {
	if x.BytesValue == nil {
		x.BytesValue = &wrapperspb.BytesValue{Value: utils.MustDecodeBase64("aGVsbG8gd29ybGQ=")}
	}
	if x.BytesValues == nil {
		x.BytesValues = &wrapperspb.BytesValue{Value: utils.MustDecodeBase64("aGVsbG8gd29ybGQ=")}
	}
	if x.BytesHexValuesx == nil {
		x.BytesHexValuesx = &wrapperspb.BytesValue{Value: utils.MustDecodeBase64("aGVsbG8gd29ybGQ=")}
	}
}

func (x *DoubleSliceTestMessage) AddFlags(fs *pflag.FlagSet, opts ...flags.Option) {
	builder := flags.NewNameBuilder(opts...)
	_ = builder
	fs.VarP(types.DoubleSlice(&x.Measurements), builder.Build("measurements"), "m", "Scientific measurements (e.g., 3.14159, 2.71828, 1.41421)")

	fs.VarP(types.DoubleSlice(&x.ScientificValues), builder.Build("scientific-values"), "sv", "Scientific notation values (e.g., 1.23e-4, 5.67e+8)")

	fs.VarP(types.DoubleSlice(&x.TemperatureReadings), builder.Build("temperature-readings"), "t", "Temperature readings in Celsius")

	fs.VarP(types.DoubleSlice(&x.Coordinates), builder.Build("coordinates"), "c", "GPS coordinates (lat, lon pairs)")

}

func (x *DoubleSliceTestMessage) SetDefaults() {
}

func (x *BytesSliceTestMessage) AddFlags(fs *pflag.FlagSet, opts ...flags.Option) {
	builder := flags.NewNameBuilder(opts...)
	_ = builder
	fs.VarP(types.BytesSlice(&x.DataChunks), builder.Build("data-chunks"), "dc", "Data chunks in base64 format")

	fs.VarP(types.BytesSlice(&x.FileContents), builder.Build("file-contents"), "fc", "File contents in base64 format")

	fs.VarP(types.BytesHexSlice(&x.HexData), builder.Build("hex-data"), "hd", "Data in hexadecimal format")

	fs.VarP(types.BytesHexSlice(&x.BinaryPayloads), builder.Build("binary-payloads"), "bp", "Binary payloads in hex format")

}

func (x *BytesSliceTestMessage) SetDefaults() {
}

func (x *FloatSliceTestMessage) AddFlags(fs *pflag.FlagSet, opts ...flags.Option) {
	builder := flags.NewNameBuilder(opts...)
	_ = builder
	fs.Float32SliceVarP(&x.Measurements, builder.Build("measurements"), "m", x.Measurements, "Scientific measurements (e.g., 3.14, 2.71, 1.41)")

	if x.Coordinates2 == nil {
		x.Coordinates2 = new(float32)
	}
	fs.Float32VarP(x.Coordinates2, builder.Build("coordinates"), "c", *(x.Coordinates2), "GPS coordinates in float format")

	fs.Float32SliceVarP(&x.Temperatures, builder.Build("temperatures"), "t", x.Temperatures, "Temperature readings in Celsius")

	fs.Float32SliceVarP(&x.Percentages, builder.Build("percentages"), "p", x.Percentages, "Percentage values (0.0 to 100.0)")

}

func (x *FloatSliceTestMessage) SetDefaults() {
}

func (x *FloatValueTestMessage) AddFlags(fs *pflag.FlagSet, opts ...flags.Option) {
	builder := flags.NewNameBuilder(opts...)
	_ = builder
	if x.SingleValue == nil {
		x.SingleValue = new(wrapperspb.FloatValue)
	}
	fs.VarP(types.Float(x.SingleValue), builder.Build("single-value"), "sv", "Single float value wrapper")

	fs.VarP(types.FloatSlice(&x.FloatValues), builder.Build("float-values"), "fvs", "Multiple FloatValue wrapper instances")

	if x.Temperature == nil {
		x.Temperature = new(wrapperspb.FloatValue)
	}
	fs.VarP(types.Float(x.Temperature), builder.Build("temperature"), "temp", "Temperature in Celsius")

	fs.VarP(types.FloatSlice(&x.SensorReadings), builder.Build("sensor-readings"), "sr", "Multiple sensor readings")

	if x.Probability == nil {
		x.Probability = new(wrapperspb.FloatValue)
	}
	fs.VarP(types.Float(x.Probability), builder.Build("probability"), "prob", "Probability value (0.0 to 1.0)")

	fs.VarP(types.FloatSlice(&x.Scores), builder.Build("scores"), "sc", "Multiple score values")

}

func (x *FloatValueTestMessage) SetDefaults() {
}

func (x *DurationSliceTestMessage) AddFlags(fs *pflag.FlagSet, opts ...flags.Option) {
	builder := flags.NewNameBuilder(opts...)
	_ = builder
	fs.VarP(types.DurationSlice(&x.Delays), builder.Build("delays"), "d", "Delay durations (e.g., 1s, 2m, 3h)")

	fs.VarP(types.DurationSlice(&x.Intervals), builder.Build("intervals"), "i", "Time intervals between events (e.g., 500ms, 10s, 5m)")

	fs.VarP(types.DurationSlice(&x.Timeouts), builder.Build("timeouts"), "t", "Timeout durations for operations (e.g., 30s, 5m, 1h)")

	fs.VarP(types.DurationSlice(&x.PollingIntervals), builder.Build("polling-intervals"), "p", "Polling intervals for monitoring (e.g., 100ms, 5s, 1m)")

	if x.Deadline == nil {
		x.Deadline = new(timestamppb.Timestamp)
	}

	fs.VarP(types.Timestamp(x.Deadline, []string{"abc"}), builder.Build("deadline"), "", "deadline usage")

	if x.OptionalDeadline == nil {
		x.OptionalDeadline = new(timestamppb.Timestamp)
	}

	fs.VarP(types.Timestamp(x.OptionalDeadline, []string{"abc"}), builder.Build("optionaldeadline"), "", "optional_deadline")

}

func (x *DurationSliceTestMessage) SetDefaults() {
	if x.Deadline == nil {
		x.Deadline = timestamppb.Now()
	}

}

func (x *EmptyMessage) AddFlags(fs *pflag.FlagSet, opts ...flags.Option) {
	builder := flags.NewNameBuilder(opts...)
	_ = builder
}

func (x *EmptyMessage) SetDefaults() {
}

func (x *WrapperMessage) AddFlags(fs *pflag.FlagSet, opts ...flags.Option) {
	builder := flags.NewNameBuilder(opts...)
	_ = builder
	if x.Value == nil {
		x.Value = new(wrapperspb.FloatValue)
	}
	fs.VarP(types.Float(x.Value), builder.Build("value"), "", "hello")

	fs.StringSliceVarP(&x.Value2, builder.Build("value2"), "", x.Value2, "This should not appear in help")

}

func (x *WrapperMessage) SetDefaults() {
}

func (x *UnexportedMessageTest) _AddFlags(fs *pflag.FlagSet, opts ...flags.Option) {
	builder := flags.NewNameBuilder(opts...)
	_ = builder
	fs.StringVarP(&x.SecretKey, builder.Build("secret-key"), "", x.SecretKey, "Secret configuration key")

	fs.MarkHidden("secret-key")

	fs.Int32VarP(&x.Timeout, builder.Build("timeout"), "", x.Timeout, "Connection timeout in seconds")

}

func (x *UnexportedMessageTest) _SetDefaults() {
	if x.Timeout == 0 {
		x.Timeout = 30
	}

}

func (x *DefaultValueTestMessage) AddFlags(fs *pflag.FlagSet, opts ...flags.Option) {
	builder := flags.NewNameBuilder(opts...)
	_ = builder
	fs.Float32VarP(&x.Pi, builder.Build("pi"), "", x.Pi, "Pi constant value")

	fs.Float64VarP(&x.Euler, builder.Build("euler"), "", x.Euler, "Euler's number")

	fs.Int32VarP(&x.DefaultPort, builder.Build("default-port"), "", x.DefaultPort, "Default server port")

	fs.Int64VarP(&x.MaxConnections, builder.Build("max-connections"), "", x.MaxConnections, "Maximum allowed connections")

	fs.Uint32VarP(&x.BufferSize, builder.Build("buffer-size"), "", x.BufferSize, "Buffer size in bytes")

	fs.Uint64VarP(&x.MemoryLimit, builder.Build("memory-limit"), "", x.MemoryLimit, "Memory limit in bytes")

	if x.DebugMode == nil {
		x.DebugMode = new(bool)
	}
	fs.BoolVarP(x.DebugMode, builder.Build("debug-mode"), "", *(x.DebugMode), "Enable debug mode")

	fs.StringVarP(&x.LogLevel, builder.Build("log-level"), "", x.LogLevel, "Default log level")

	fs.VarP(types.Enum(&x.DefaultMode), builder.Build("default-mode"), "", "Default operation mode")

	if x.DefaultMode2 == nil {
		x.DefaultMode2 = new(TestEnum1)
	}

	fs.VarP(types.Enum(x.DefaultMode2), builder.Build("default-mode1"), "", "Default operation mode")

}

func (x *DefaultValueTestMessage) SetDefaults() {
	if x.Pi == 0 {
		x.Pi = 3.14159
	}

	if x.Euler == 0 {
		x.Euler = 2.71828
	}

	if x.DefaultPort == 0 {
		x.DefaultPort = 8080
	}

	if x.MaxConnections == 0 {
		x.MaxConnections = 1000
	}

	if x.BufferSize == 0 {
		x.BufferSize = 4096
	}

	if x.MemoryLimit == 0 {
		x.MemoryLimit = 1073741824
	}

	if x.DebugMode == nil {
		v := bool(true)
		x.DebugMode = &v
	}

	if x.LogLevel == "" {
		x.LogLevel = "info"
	}

	if x.DefaultMode == 0 {
		x.DefaultMode = 1
	}

	if x.DefaultMode2 == nil {
		v := TestEnum1(1)
		x.DefaultMode2 = &v
	}

}

func (x *StringValueTestMessage) AddFlags(fs *pflag.FlagSet, opts ...flags.Option) {
	builder := flags.NewNameBuilder(opts...)
	_ = builder
	if x.SingleValue == nil {
		x.SingleValue = new(wrapperspb.StringValue)
	}
	fs.VarP(types.String(x.SingleValue), builder.Build("single-value"), "sv", "Single string value wrapper")

	fs.VarP(types.StringSlice(&x.StringValues), builder.Build("string-values"), "svs", "Multiple StringValue wrapper instances")

	if x.ConfigPath == nil {
		x.ConfigPath = new(wrapperspb.StringValue)
	}
	fs.VarP(types.String(x.ConfigPath), builder.Build("config-path"), "cfg", "Configuration file path")

	fs.VarP(types.StringSlice(&x.IncludePaths), builder.Build("include-paths"), "inc", "Include paths for configuration")

	if x.Environment == nil {
		x.Environment = new(wrapperspb.StringValue)
	}
	fs.VarP(types.String(x.Environment), builder.Build("environment"), "env", "Environment name")

	fs.VarP(types.StringSlice(&x.Tags), builder.Build("tags"), "t", "Multiple tags for categorization")

}

func (x *StringValueTestMessage) SetDefaults() {
	if x.SingleValue == nil {
		x.SingleValue = &wrapperspb.StringValue{Value: "default-single"}
	}

	if x.ConfigPath == nil {
		x.ConfigPath = &wrapperspb.StringValue{Value: "/etc/config.yaml"}
	}

	if x.Environment == nil {
		x.Environment = &wrapperspb.StringValue{Value: "production"}
	}

}

func (x *IntegerValueTestMessage) AddFlags(fs *pflag.FlagSet, opts ...flags.Option) {
	builder := flags.NewNameBuilder(opts...)
	_ = builder
	if x.Int32Value == nil {
		x.Int32Value = new(wrapperspb.Int32Value)
	}
	fs.VarP(types.Int32(x.Int32Value), builder.Build("int32-value"), "i32", "Int32 value wrapper")

	if x.Int64Value == nil {
		x.Int64Value = new(wrapperspb.Int64Value)
	}
	fs.VarP(types.Int64(x.Int64Value), builder.Build("int64-value"), "i64", "Int64 value wrapper")

	if x.Uint32Value == nil {
		x.Uint32Value = new(wrapperspb.UInt32Value)
	}
	fs.VarP(types.UInt32(x.Uint32Value), builder.Build("uint32-value"), "u32", "UInt32 value wrapper")

	if x.Uint64Value == nil {
		x.Uint64Value = new(wrapperspb.UInt64Value)
	}
	fs.VarP(types.UInt64(x.Uint64Value), builder.Build("uint64-value"), "u64", "UInt64 value wrapper")

	fs.VarP(types.Int32Slice(&x.Int32Values), builder.Build("int32-values"), "i32s", "Multiple Int32 value wrapper instances")

	fs.VarP(types.Int64Slice(&x.Int64Values), builder.Build("int64-values"), "i64s", "Multiple Int64 value wrapper instances")

	fs.VarP(types.FloatSlice(&x.Float64Values), builder.Build("int64-valuesx"), "i64s", "Multiple FloatValue wrapper instances")

	fs.Float64SliceVarP(&x.DoubleValues, builder.Build("double-valuesx"), "i64sx", x.DoubleValues, "Multiple double value instances")

}

func (x *IntegerValueTestMessage) SetDefaults() {
	if x.Int32Value == nil {
		x.Int32Value = &wrapperspb.Int32Value{Value: 42}
	}

	if x.Int64Value == nil {
		x.Int64Value = &wrapperspb.Int64Value{Value: 9223372036854775807}
	}

	if x.Uint32Value == nil {
		x.Uint32Value = &wrapperspb.UInt32Value{Value: 100}
	}

	if x.Uint64Value == nil {
		x.Uint64Value = &wrapperspb.UInt64Value{Value: 18446744073709551615}
	}

	if len(x.Int64Values) == 0 {
		x.Int64Values = []*wrapperspb.Int64Value{{Value: 1}, {Value: 2}}
	}

	if len(x.Float64Values) == 0 {
		x.Float64Values = []*wrapperspb.FloatValue{{Value: 1.000000}, {Value: 2.000000}}
	}

	if len(x.DoubleValues) == 0 {
		x.DoubleValues = []float64{1.000000, 2.000000}
	}

}

func (x *BoolValueTestMessage) AddFlags(fs *pflag.FlagSet, opts ...flags.Option) {
	builder := flags.NewNameBuilder(opts...)
	_ = builder
	if x.SingleValue == nil {
		x.SingleValue = new(wrapperspb.BoolValue)
	}
	fs.VarP(types.Bool(x.SingleValue), builder.Build("single-value"), "sv", "Single boolean value wrapper")

	fs.VarP(types.BoolSlice(&x.BoolValues), builder.Build("bool-values"), "bvs", "Multiple BoolValue wrapper instances")

	if x.EnableFeature == nil {
		x.EnableFeature = new(wrapperspb.BoolValue)
	}
	fs.VarP(types.Bool(x.EnableFeature), builder.Build("enable-feature"), "feat", "Enable experimental feature")

	fs.VarP(types.BoolSlice(&x.FeatureFlags), builder.Build("feature-flags"), "ff", "Multiple feature flags")

	if x.VerboseLogging == nil {
		x.VerboseLogging = new(wrapperspb.BoolValue)
	}
	fs.VarP(types.Bool(x.VerboseLogging), builder.Build("verbose-logging"), "verbose", "Enable verbose logging")

	fs.VarP(types.BoolSlice(&x.DebugOptions), builder.Build("debug-options"), "dbg", "Multiple debug option flags")

}

func (x *BoolValueTestMessage) SetDefaults() {
	if x.SingleValue == nil {
		x.SingleValue = &wrapperspb.BoolValue{Value: true}
	}

	if x.EnableFeature == nil {
		x.EnableFeature = &wrapperspb.BoolValue{Value: false}
	}

	if x.VerboseLogging == nil {
		x.VerboseLogging = &wrapperspb.BoolValue{Value: false}
	}

}

func (x *ComprehensiveFlagTestMessage) AddFlags(fs *pflag.FlagSet, opts ...flags.Option) {
	builder := flags.NewNameBuilder(opts...)
	_ = builder
	fs.StringVarP(&x.Username, builder.Build("username"), "u", x.Username, "Username for authentication")

	fs.StringVarP(&x.Password, builder.Build("password"), "p", x.Password, "Password for authentication")

	fs.MarkHidden("password")

	fs.StringVarP(&x.LegacyToken, builder.Build("legacy-token"), "lt", x.LegacyToken, "Legacy authentication token")

	fs.MarkDeprecated("legacy-token", "Use --api-key instead")

	fs.Int32VarP(&x.ConnectionCount, builder.Build("connection-count"), "cc", x.ConnectionCount, "Number of concurrent connections")

	fs.Int32VarP(&x.MaxThreads, builder.Build("max-threads"), "mt", x.MaxThreads, "Maximum number of threads")

	fs.MarkDeprecated("max-threads", "Use --worker-count instead")

	fs.BoolVarP(&x.ExperimentalMode, builder.Build("experimental-mode"), "exp", x.ExperimentalMode, "Enable experimental features")

	fs.MarkHidden("experimental-mode")

}

func (x *ComprehensiveFlagTestMessage) SetDefaults() {
	if x.Username == "" {
		x.Username = "admin"
	}

	if x.ConnectionCount == 0 {
		x.ConnectionCount = 10
	}

	if x.MaxThreads == 0 {
		x.MaxThreads = 100
	}

	if x.ExperimentalMode == false {
		x.ExperimentalMode = false
	}

}

func (x *NestedMessageTestMessage) AddFlags(fs *pflag.FlagSet, opts ...flags.Option) {
	builder := flags.NewNameBuilder(opts...)
	_ = builder
	if x.ServerConfig == nil {
		x.ServerConfig = new(SimpleMessage)
	}

	if v, ok := interface{}(x.ServerConfig).(flags.Flagger); ok {
		v.AddFlags(fs, append(opts, flags.WithPrefix("server"))...)
	}

	if x.ClientConfig == nil {
		x.ClientConfig = new(SimpleMessage)
	}

	if v, ok := interface{}(x.ClientConfig).(flags.Flagger); ok {
		v.AddFlags(fs, append(opts, flags.WithPrefix("client_config"))...)
	}

	if x.DatabaseConfig == nil {
		x.DatabaseConfig = new(SimpleMessage)
	}

	if v, ok := interface{}(x.DatabaseConfig).(flags.Flagger); ok {
		v.AddFlags(fs, append(opts, flags.WithPrefix("db"))...)
	}

	if x.DeepConfig == nil {
		x.DeepConfig = new(NestedLevel2Message)
	}

	if v, ok := interface{}(x.DeepConfig).(flags.Flagger); ok {
		v.AddFlags(fs, append(opts, flags.WithPrefix("app"))...)
	}

}

func (x *NestedMessageTestMessage) SetDefaults() {
	if x.ServerConfig == nil {
		x.ServerConfig = new(SimpleMessage)
	}

	if v, ok := interface{}(x.ServerConfig).(flags.Defaulter); ok {
		v.SetDefaults()
	}

	if x.ClientConfig == nil {
		x.ClientConfig = new(SimpleMessage)
	}

	if v, ok := interface{}(x.ClientConfig).(flags.Defaulter); ok {
		v.SetDefaults()
	}

	if x.DatabaseConfig == nil {
		x.DatabaseConfig = new(SimpleMessage)
	}

	if v, ok := interface{}(x.DatabaseConfig).(flags.Defaulter); ok {
		v.SetDefaults()
	}

	if x.DeepConfig == nil {
		x.DeepConfig = new(NestedLevel2Message)
	}

	if v, ok := interface{}(x.DeepConfig).(flags.Defaulter); ok {
		v.SetDefaults()
	}

}

func (x *NestedLevel2Message) AddFlags(fs *pflag.FlagSet, opts ...flags.Option) {
	builder := flags.NewNameBuilder(opts...)
	_ = builder
	fs.StringVarP(&x.Level2Field, builder.Build("level2-field"), "", x.Level2Field, "Level 2 nested field")

	if x.NestedSimple == nil {
		x.NestedSimple = new(SimpleMessage)
	}

	if v, ok := interface{}(x.NestedSimple).(flags.Flagger); ok {
		v.AddFlags(fs, append(opts, flags.WithPrefix("nested"))...)
	}

}

func (x *NestedLevel2Message) SetDefaults() {
	if x.NestedSimple == nil {
		x.NestedSimple = new(SimpleMessage)
	}

	if v, ok := interface{}(x.NestedSimple).(flags.Defaulter); ok {
		v.SetDefaults()
	}

}

func (x *ComprehensiveMapTestMessage) AddFlags(fs *pflag.FlagSet, opts ...flags.Option) {
	builder := flags.NewNameBuilder(opts...)
	_ = builder
	fs.VarP(types.JSON(&x.JsonLabels), builder.Build("json-labels"), "jl", "Labels in JSON format")

	fs.StringToStringVarP(&x.NativeLabels, builder.Build("native-labels"), "nl", x.NativeLabels, "Labels in native format")

	fs.VarP(types.StringToInt32(&x.DefaultCounters), builder.Build("default-counters"), "dc", "Default counter values")

	fs.VarP(types.JSON(&x.LegacyConfig), builder.Build("legacy-config"), "lc", "Legacy configuration map")

	fs.MarkDeprecated("legacy-config", "Use --new-config instead")

	fs.VarP(types.JSON(&x.SecretConfig), builder.Build("secret-config"), "sc", "Secret configuration map")

	fs.MarkHidden("secret-config")

}

func (x *ComprehensiveMapTestMessage) SetDefaults() {
}

func (x *TimestampSliceTestMessage) AddFlags(fs *pflag.FlagSet, opts ...flags.Option) {
	builder := flags.NewNameBuilder(opts...)
	_ = builder
	fs.VarP(types.TimestampSlice(&x.EventTimes, []string{"RFC3339"}), builder.Build("event-times"), "et", "Event timestamps (e.g., 2023-01-01T00:00:00Z, 2023-12-31T23:59:59Z)")

	fs.VarP(types.TimestampSlice(&x.LogTimestamps, []string{"RFC3339"}), builder.Build("log-timestamps"), "lt", "Log entry timestamps in RFC3339 format")

	fs.VarP(types.TimestampSlice(&x.ScheduledTasks, []string{"RFC3339"}), builder.Build("scheduled-tasks"), "st", "Scheduled task execution times")

	fs.VarP(types.TimestampSlice(&x.BackupTimes, []string{"RFC3339"}), builder.Build("backup-times"), "bt", "Backup schedule timestamps (e.g., 2024-01-01T02:00:00Z)")

	fs.VarP(types.TimestampSlice(&x.CustomFormatTimes, []string{"RFC3339", "ISO8601", "RFC822"}), builder.Build("custom-format-times"), "cft", "Custom format timestamps")

}

func (x *TimestampSliceTestMessage) SetDefaults() {
	if len(x.EventTimes) == 0 {
		x.EventTimes = []*timestamppb.Timestamp{&timestamppb.Timestamp{Seconds: 1703500200, Nanos: 0}, timestamppb.Now()}
	}

}

func (x *RepeatedBytesTestMessage) AddFlags(fs *pflag.FlagSet, opts ...flags.Option) {
	builder := flags.NewNameBuilder(opts...)
	_ = builder
	fs.VarP(types.BytesSlice(&x.Base64Chunks), builder.Build("base64-chunks"), "b64", "Data chunks in base64 format")

	fs.VarP(types.BytesHexSlice(&x.HexChunks), builder.Build("hex-chunks"), "hx", "Data chunks in hex format")

	fs.VarP(types.BytesSlice(&x.DefaultBase64), builder.Build("default-base64"), "db64", "Default base64 encoded values")

	fs.VarP(types.BytesHexSlice(&x.DefaultHex), builder.Build("default-hex"), "dhx", "Default hex encoded values")

	fs.VarP(types.BytesSlice(&x.RawChunks), builder.Build("raw-chunks"), "rc", "Raw data chunks (defaults to base64)")

	fs.VarP(types.BytesHexSlice(&x.MixedHex), builder.Build("mixed-hex"), "mh", "Mixed case hex data")

	fs.VarP(types.BytesSlice(&x.SpecialB64), builder.Build("special_b64"), "sb64", "Special character base64 data")

}

func (x *RepeatedBytesTestMessage) SetDefaults() {
	if len(x.DefaultBase64) == 0 {
		x.DefaultBase64 = []*wrapperspb.BytesValue{{Value: utils.MustDecodeBase64("SGVsbG8gV29ybGQ=")}, {Value: utils.MustDecodeBase64("VGVzdCBEYXRh")}, {Value: utils.MustDecodeBase64("U2FtcGxlIENvbnRlbnQ=")}}
	}
	if len(x.DefaultHex) == 0 {
		x.DefaultHex = []*wrapperspb.BytesValue{{Value: utils.MustDecodeHex("48656c6c6f20576f726c64")}, {Value: utils.MustDecodeHex("546573742044617461")}, {Value: utils.MustDecodeHex("53616d706c6520436f6e74656e74")}}
	}
	if len(x.MixedHex) == 0 {
		x.MixedHex = [][]byte{utils.MustDecodeHex("aBc123DeF456"), utils.MustDecodeHex("789AbCdE0123"), utils.MustDecodeHex("fFeEdDcCbBaA")}
	}
	if len(x.SpecialB64) == 0 {
		x.SpecialB64 = [][]byte{utils.MustDecodeBase64("w6TDtsO8w4Q="), utils.MustDecodeBase64("8J+YgA=="), utils.MustDecodeBase64("w4PDoMOgw6E=")}
	}
}
