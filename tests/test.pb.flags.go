// Copyright 2021 Linka Cloud  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-flags. DO NOT EDIT.

package tests

import (
	"github.com/kunstack/protoc-gen-flags/flags"
	"github.com/kunstack/protoc-gen-flags/types"
	"github.com/kunstack/protoc-gen-flags/utils"
	"github.com/spf13/pflag"
	"google.golang.org/protobuf/types/known/durationpb"
	"google.golang.org/protobuf/types/known/timestamppb"
	"google.golang.org/protobuf/types/known/wrapperspb"
)

var (
	_ = pflag.NewFlagSet
	_ = utils.BuildFlagName
	_ = types.Bool
	_ = flags.Interface(nil)
	_ = wrapperspb.String
	_ = (*durationpb.Duration)(nil)
	_ = (*timestamppb.Timestamp)(nil)
)

func (x *TestForMessage) AddFlags(fs *pflag.FlagSet, prefix ...string) {
	fs.Float32VarP(&x.Hello, utils.BuildFlagName(prefix, "hello"), "h", x.Hello, "Hello world '\"' flag")

	fs.MarkHidden("hello")

	fs.MarkDeprecated("hello", "This flag is deprecated, use --greeting instead")

	fs.StringVarP(&x.World, utils.BuildFlagName(prefix, "world"), "", x.World, "World flags (can be specified multiple times)")

	fs.MarkDeprecated("world", "This flag is deprecated, use --target instead")

	fs.StringVarP(&x.Greeting, utils.BuildFlagName(prefix, "greeting"), "g", x.Greeting, "Greeting message to display")

	fs.Int32VarP(&x.Count, utils.BuildFlagName(prefix, "count"), "c", x.Count, "Number of times to repeat the message")

	fs.BoolVarP(&x.Verbose, utils.BuildFlagName(prefix, "verbose"), "v", x.Verbose, "Enable verbose output")

	fs.Int64VarP(&x.Verbose2, utils.BuildFlagName(prefix, "verbose2"), "V", x.Verbose2, "Enable verbose output with sfixed64")

	fs.Int64VarP(&x.UserId, utils.BuildFlagName(prefix, "user-id"), "u", x.UserId, "User ID")

	fs.Uint32VarP(&x.Port, utils.BuildFlagName(prefix, "port"), "p", x.Port, "Port number")

	fs.Uint64VarP(&x.Size, utils.BuildFlagName(prefix, "size"), "s", x.Size, "Size in bytes")

	fs.Int32VarP(&x.Temperature, utils.BuildFlagName(prefix, "temperature"), "t", x.Temperature, "Temperature value")

	fs.Int64VarP(&x.Timestamp, utils.BuildFlagName(prefix, "timestamp"), "T", x.Timestamp, "Timestamp value")

	fs.Uint32VarP(&x.Timeout, utils.BuildFlagName(prefix, "timeout"), "", x.Timeout, "Timeout in milliseconds")

	fs.Uint64VarP(&x.Bandwidth, utils.BuildFlagName(prefix, "bandwidth"), "", x.Bandwidth, "Bandwidth in bits per second")

	fs.Int32VarP(&x.Offset, utils.BuildFlagName(prefix, "offset"), "", x.Offset, "Offset value")

	fs.Float64VarP(&x.Ratio, utils.BuildFlagName(prefix, "ratio"), "r", x.Ratio, "Ratio value")

	fs.BytesHexVarP(&x.Byte, utils.BuildFlagName(prefix, "byte"), "b", x.Byte, "Byte data in base64 encoding")

	fs.BytesBase64VarP(&x.ConfigData, utils.BuildFlagName(prefix, "config-data"), "cd", x.ConfigData, "Configuration data in base64 format")

	fs.BytesHexVarP(&x.SecretKey, utils.BuildFlagName(prefix, "secret-key"), "sk", x.SecretKey, "Secret key in hex format")

	fs.MarkHidden("secret-key")

	fs.VarP(types.BytesSlice(&x.FileChunks), utils.BuildFlagName(prefix, "file-chunks"), "fc", "File chunks in base64 format")

	fs.VarP(types.BytesHexSlice(&x.HexChunks), utils.BuildFlagName(prefix, "hex-chunks"), "hc", "Data chunks in hex format")
	fs.VarP(types.Enum(&x.TestEnum), utils.BuildFlagName(prefix, "test-enum"), "e", "Test enum field")

	if x.TimeoutDuration == nil {
		x.TimeoutDuration = new(durationpb.Duration)
	}

	fs.VarP(types.Duration(x.TimeoutDuration), utils.BuildFlagName(prefix, "timeout-duration"), "d", "Timeout duration (e.g., 30s, 5m, 1h)")

	if x.SimpleField == nil {
		x.SimpleField = new(SimpleMessage)
	}

	if v, ok := interface{}(x.SimpleField).(flags.Interface); ok {
		v.AddFlags(fs, "simple-field")
	}

	fs.StringToStringVarP(&x.Labels, utils.BuildFlagName(prefix, "labels"), "l", x.Labels, "Key-value labels (JSON format)")

	fs.VarP(types.JSON(&x.Counters), utils.BuildFlagName(prefix, "counters"), "", "String-to-integer counters (JSON format)")

	fs.StringToStringVarP(&x.StringMap, utils.BuildFlagName(prefix, "string-map"), "sm", x.StringMap, "String-to-string map using native format")

	fs.VarP(types.StringToInt32(&x.Int32Map), utils.BuildFlagName(prefix, "int32-map"), "i32", "String-to-int32 map using native format")

	fs.StringToInt64VarP(&x.Int64Map, utils.BuildFlagName(prefix, "int64-map"), "i64", x.Int64Map, "String-to-int64 map using native format")

	fs.VarP(types.StringToUint32(&x.Uint32Map), utils.BuildFlagName(prefix, "uint32-map"), "u32", "String-to-uint32 map using native format")

	fs.VarP(types.StringToUint64(&x.Uint64Map), utils.BuildFlagName(prefix, "uint64-map"), "u64", "String-to-uint64 map using native format")

	fs.VarP(types.StringToInt32(&x.Sfixed32Map), utils.BuildFlagName(prefix, "sfixed32-map"), "sf32", "String-to-sfixed32 map using native format")

	fs.StringToInt64VarP(&x.Sfixed64Map, utils.BuildFlagName(prefix, "sfixed64-map"), "sf64", x.Sfixed64Map, "String-to-sfixed64 map using native format")

	fs.VarP(types.JSON(&x.JsonMap), utils.BuildFlagName(prefix, "json-map"), "j", "Generic JSON map format")

	fs.StringSliceVarP(&x.RepeatedStrings, utils.BuildFlagName(prefix, "repeated-strings"), "rs", x.RepeatedStrings, "Repeated strings for comparison")

	fs.VarP(types.DurationSlice(&x.Delays), utils.BuildFlagName(prefix, "delays"), "d", "Delay durations (e.g., 1s, 2m, 3h)")

	fs.VarP(types.DurationSlice(&x.Intervals), utils.BuildFlagName(prefix, "intervals"), "i", "Time intervals between events")

	fs.VarP(types.DurationSlice(&x.Timeouts), utils.BuildFlagName(prefix, "timeouts"), "t", "Timeout durations for operations")

}

func (x *SimpleMessage) AddFlags(fs *pflag.FlagSet, prefix ...string) {
	fs.StringVarP(&x.Name, utils.BuildFlagName(prefix, "name"), "", x.Name, "Name parameter")

}

func (x *WrapperValueMessage) AddFlags(fs *pflag.FlagSet, prefix ...string) {
	fs.VarP(types.BoolSlice(&x.Name), utils.BuildFlagName(prefix, "name"), "", "Name parameter")

	if x.DoubleValue == nil {
		x.DoubleValue = new(wrapperspb.DoubleValue)
	}
	fs.VarP(types.Double(x.DoubleValue), utils.BuildFlagName(prefix, "double-value"), "dv", "Double value wrapper")

	fs.VarP(types.DoubleSlice(&x.DoubleValues), utils.BuildFlagName(prefix, "double-values"), "dvs", "Multiple double values")

	if x.BytesValue == nil {
		x.BytesValue = new(wrapperspb.BytesValue)
	}

	fs.VarP(types.Bytes(x.BytesValue), utils.BuildFlagName(prefix, "bytes-value"), "bv", "Bytes value wrapper (base64 encoded)")

	fs.VarP(types.BytesSlice(&x.BytesValues), utils.BuildFlagName(prefix, "bytes-values"), "bvs", "Multiple bytes values (base64 encoded)")

	fs.VarP(types.BytesHexSlice(&x.BytesHexValues), utils.BuildFlagName(prefix, "bytes-hex-values"), "bhx", "Multiple bytes values (hex encoded)")

}

func (x *DoubleSliceTestMessage) AddFlags(fs *pflag.FlagSet, prefix ...string) {
	fs.VarP(types.DoubleSlice(&x.Measurements), utils.BuildFlagName(prefix, "measurements"), "m", "Scientific measurements (e.g., 3.14159, 2.71828, 1.41421)")

	fs.VarP(types.DoubleSlice(&x.ScientificValues), utils.BuildFlagName(prefix, "scientific-values"), "sv", "Scientific notation values (e.g., 1.23e-4, 5.67e+8)")

	fs.VarP(types.DoubleSlice(&x.TemperatureReadings), utils.BuildFlagName(prefix, "temperature-readings"), "t", "Temperature readings in Celsius")

	fs.VarP(types.DoubleSlice(&x.Coordinates), utils.BuildFlagName(prefix, "coordinates"), "c", "GPS coordinates (lat, lon pairs)")

}

func (x *BytesSliceTestMessage) AddFlags(fs *pflag.FlagSet, prefix ...string) {
	fs.VarP(types.BytesSlice(&x.DataChunks), utils.BuildFlagName(prefix, "data-chunks"), "dc", "Data chunks in base64 format")

	fs.VarP(types.BytesSlice(&x.FileContents), utils.BuildFlagName(prefix, "file-contents"), "fc", "File contents in base64 format")

	fs.VarP(types.BytesHexSlice(&x.HexData), utils.BuildFlagName(prefix, "hex-data"), "hd", "Data in hexadecimal format")

	fs.VarP(types.BytesHexSlice(&x.BinaryPayloads), utils.BuildFlagName(prefix, "binary-payloads"), "bp", "Binary payloads in hex format")

}

func (x *FloatSliceTestMessage) AddFlags(fs *pflag.FlagSet, prefix ...string) {
	fs.Float32SliceVarP(&x.Measurements, utils.BuildFlagName(prefix, "measurements"), "m", x.Measurements, "Scientific measurements (e.g., 3.14, 2.71, 1.41)")

	if x.Coordinates2 == nil {
		x.Coordinates2 = new(float32)
	}
	fs.Float32VarP(x.Coordinates2, utils.BuildFlagName(prefix, "coordinates"), "c", *(x.Coordinates2), "GPS coordinates in float format")

	fs.Float32SliceVarP(&x.Temperatures, utils.BuildFlagName(prefix, "temperatures"), "t", x.Temperatures, "Temperature readings in Celsius")

	fs.Float32SliceVarP(&x.Percentages, utils.BuildFlagName(prefix, "percentages"), "p", x.Percentages, "Percentage values (0.0 to 100.0)")

}

func (x *FloatValueTestMessage) AddFlags(fs *pflag.FlagSet, prefix ...string) {
	if x.SingleValue == nil {
		x.SingleValue = new(wrapperspb.FloatValue)
	}
	fs.VarP(types.Float(x.SingleValue), utils.BuildFlagName(prefix, "single-value"), "sv", "Single float value wrapper")

	fs.VarP(types.FloatSlice(&x.FloatValues), utils.BuildFlagName(prefix, "float-values"), "fvs", "Multiple FloatValue wrapper instances")

	if x.Temperature == nil {
		x.Temperature = new(wrapperspb.FloatValue)
	}
	fs.VarP(types.Float(x.Temperature), utils.BuildFlagName(prefix, "temperature"), "temp", "Temperature in Celsius")

	fs.VarP(types.FloatSlice(&x.SensorReadings), utils.BuildFlagName(prefix, "sensor-readings"), "sr", "Multiple sensor readings")

	if x.Probability == nil {
		x.Probability = new(wrapperspb.FloatValue)
	}
	fs.VarP(types.Float(x.Probability), utils.BuildFlagName(prefix, "probability"), "prob", "Probability value (0.0 to 1.0)")

	fs.VarP(types.FloatSlice(&x.Scores), utils.BuildFlagName(prefix, "scores"), "sc", "Multiple score values")

}

func (x *DurationSliceTestMessage) AddFlags(fs *pflag.FlagSet, prefix ...string) {
	fs.VarP(types.DurationSlice(&x.Delays), utils.BuildFlagName(prefix, "delays"), "d", "Delay durations (e.g., 1s, 2m, 3h)")

	fs.VarP(types.DurationSlice(&x.Intervals), utils.BuildFlagName(prefix, "intervals"), "i", "Time intervals between events (e.g., 500ms, 10s, 5m)")

	fs.VarP(types.DurationSlice(&x.Timeouts), utils.BuildFlagName(prefix, "timeouts"), "t", "Timeout durations for operations (e.g., 30s, 5m, 1h)")

	fs.VarP(types.DurationSlice(&x.PollingIntervals), utils.BuildFlagName(prefix, "polling-intervals"), "p", "Polling intervals for monitoring (e.g., 100ms, 5s, 1m)")

	if x.Deadline == nil {
		x.Deadline = new(timestamppb.Timestamp)
	}

	fs.VarP(types.Timestamp(x.Deadline, []string{"abc"}), utils.BuildFlagName(prefix, "deadline"), "", "deadline usage")

	if x.OptionalDeadline == nil {
		x.OptionalDeadline = new(timestamppb.Timestamp)
	}

	fs.VarP(types.Timestamp(x.OptionalDeadline, []string{"abc"}), utils.BuildFlagName(prefix, "optionaldeadline"), "", "optional_deadline")

}

func (x *EmptyMessage) AddFlags(fs *pflag.FlagSet, prefix ...string) {
}

func (x *WrapperMessage) AddFlags(fs *pflag.FlagSet, prefix ...string) {
	if x.Value == nil {
		x.Value = new(wrapperspb.FloatValue)
	}
	fs.VarP(types.Float(x.Value), utils.BuildFlagName(prefix, "value"), "", "hello")

	fs.StringSliceVarP(&x.Value2, utils.BuildFlagName(prefix, "value2"), "", x.Value2, "This should not appear in help")

}
